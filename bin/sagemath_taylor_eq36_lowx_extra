#!/usr/bin/env -S sage -python
# -*- mode: python; -*-
import sys
import os
from sage.all import ( var, assume, unicode_art,
                       Integer as sage_int,
                       exp, log, sqrt, sin,
                       infinity as sage_infinity,
                       pi as sage_pi )

modes = ('primary','scndgauss','scndlorentz','scndfresnel')

args=sys.argv[1:]

if not args or ('-h' in args) or ('--help' in args):
    print("Usage:\n")
    print("%s [forrecipe] [forpiminus0] [%s]"%(os.path.basename(sys.argv[0]),
                                               '|'.join(modes)))
    raise SystemExit(1)
do_for_recipes = False
while 'forrecipe' in args:
    args.remove('forrecipe')
    do_for_recipes = True
do_forpiminus0 = False
while 'forpiminus0' in args:
    args.remove('forpiminus0')
    do_forpiminus0 = True
    do_for_recipes = True#implied
do_fory0 = False
while 'fory0' in args:
    args.remove('fory0')
    do_fory0 = True
    do_for_recipes = True#implied
assert not (do_fory0 and do_forpiminus0)

if not len(args)==1 or args[0] not in modes:
    raise SystemExit('Error: Please run with one of the following arguments: %s'%(' '.join(modes)))
mode = args[0]

eta,s,x,sinth = var('eta,s,x,sinth')
assume(eta>=0,s>=0,x>0,sinth>=0,sinth<=1)

if mode=='primary':
    eq36_normfactor = sage_int(3)/(sage_int(4)*sage_pi)
    phi_arg_extra_factor = sage_int(1)
    f=(eta**2-eta*sin(2*eta)+(sin(eta))**2)/eta**4
    order = sage_int(30)
elif mode=='scndgauss':
    eq36_normfactor = sage_int(3)/(sage_int(4)*sage_pi)
    phi_arg_extra_factor = sage_int(1)
    f = exp( - (sage_int(9)/(sage_int(16)*sage_pi)) * eta**2 )
    order = sage_int(60)
elif mode=='scndlorentz':
    eq36_normfactor = sage_int(1)/sage_pi
    phi_arg_extra_factor = sage_int(4)/sage_int(3)
    f= sage_int(1)/(sage_int(1)+eta**2)
    order = sage_int(60)
elif mode=='scndfresnel':
    eq36_normfactor = sage_int(3)/(sage_int(4)*sage_pi)
    phi_arg_extra_factor = sage_int(1)
    f= (sin(sage_int(3)*eta/sage_int(4))/(sage_int(3)*eta/sage_int(4)))**2
    order = sage_int(20)
else:
    assert False
if do_for_recipes:
    order = sage_int(8)

k_norm = sage_int(2)*eq36_normfactor #double, since only integrating over [0,inf[
phipi=(3/(4*s**3))*(s**2-s+log(1+2*s)/2)
phi0 = (3/(64*s**3))*(8*(s**2)+4*s*exp(-4*s)-(1-exp(-4*s)))
phi=phi0(s=s)+sinth**(sage_int(3)/sage_int(2))*(phipi(s=s*sqrt(sinth))-phi0(s=s*sqrt(sinth)))
if do_fory0:
    phi=phi0

#We denote the integrand of eq. 36 as g:
g=f(eta=eta)*phi(s=phi_arg_extra_factor*x*f(eta=eta))

print("Considering the integrand g(eta) given as:")
print()
print(unicode_art(g))

print("We Taylor expand the integrand in x:")
g_taylor = g.taylor(x,sage_int(0),sage_int(order))


print("And now integrate over eta from 0 to infinity term by term.")
print()
print("This might take some time (should be less than a few minutes)...")

result = sage_int(0)
for e in g_taylor.coefficients(x):
    x_order = e[1]
    assert int(x_order) == x_order
    print(f"... dealing with order {int(x_order)}")
    c = (e[0]*k_norm).simplify().factor().integrate(eta,sage_int(0),sage_infinity)
    result += c * x**int(x_order)

print("... done")
print(unicode_art(result.collect(x)))

use_u_eq_2x = not do_for_recipes


#print("TEST:",result(sinth=sage_int(1)/20,x=sage_int(1)/10).n(digits=100))
#print()
print("Code suitable for Python mpmath code. Note that we use the last three")
print("terms of the Taylor expansion as an upper bound on the error")
def fmt_mpf( v, arg_only = False ):
    def wrapm_always( v ):
        return 'm(%s)'%v
    def wrapm_if_needed( v ):
        v=str(v)
        if 'm(' in v or 'mp.' in v:
            return v
        return v if v.isdigit() else wrapm_always('"%s"'%v)
    def wrapm_if_not_int( v ):
        v=str(v)
        return v if v.isdigit() else wrapm_if_needed(v)
    half = sage_int(1)/sage_int(2)
    factor_list = ( v.factor_list()
                    if hasattr(v,'factor_list')
                    else [(v,1)] )
    assert all( pow==1 or pow==half
                for base,pow in factor_list )
    def fmt_factor( b,p ):
        if p == 1:
            return wrapm_if_needed(b)
        assert p == half
        return 'mp.sqrt(%s)'%wrapm_if_not_int(b)
    return '*'.join(fmt_factor(*e) for e in factor_list)

print('    m = mpf')
print('    sinth = m(sinth)')
print('    def s( power ):')
print('        return sinth**m(power)')
u=var('u')
assume(u>=0)
if use_u_eq_2x:
    result = result(x=u/2).simplify().collect(u)
else:
    result = result(x=u).simplify().collect(u)

for e in result.coefficients(u):
    u_order = e[1]
    if do_forpiminus0:
        e[0] = (e[0](sinth=1)-e[0](sinth=0))
    ci = e[0].simplify().factor()
    terms_ci = []
    for es in ci.coefficients(sinth):
        sinth_order = es[1]
        sinth_coeff = es[0]
        terms_ci.append(fmt_mpf(sinth_coeff,arg_only=False))
        if sinth_order != 0:
            terms_ci[-1] += '*s(%s)'%fmt_mpf(sinth_order,arg_only=True)
    terms_ci = '+'.join(terms_ci)
    if terms_ci.isdigit():
        terms_ci = 'm(%s)'%terms_ci
    print('    c%i = %s'%(u_order,terms_ci))
print('    def calc_taylor( x ):')
if use_u_eq_2x:
    print('        u = m(x)*m(2) # Keep coefficients small by this variable change')
    vn='u'
else:
    vn='x'
print(f'        return c0+{vn}*'+''.join('(c%i+%s*'%(i,vn) for i in range(1,order))+'c%i'%order+')'*(order-1))
print('    def calc_taylor_errorbound( x ):')
print('        # very conservative error bound, based on absolute size of')
print('        # contributions of last three orders')
if use_u_eq_2x:
    print('        u = m(x)*m(2) # Keep coefficients small by this variable change')
    print('        return (%s**%i)*(abs(c%i)+%s*(abs(c%i)+%s*abs(c%i)))'%( vn,
                                                                           int(order)-2,
                                                                           int(order)-2,
                                                                           vn,
                                                                           int(order)-1,
                                                                           vn,
                                                                           int(order) ) )
