#!/usr/bin/env -S sage -python
# -*- mode: python; -*-

from sage.all import ( var, assume, unicode_art, Integer as sage_int,
                       log )

s = var('s')
assume(s>=0)

# phi^pi(s) (s=sigma*r) given by eq. 32.
#
# phi^pi(s) = ( 3/(4*s**3) )*( s**2 - s + log(1+2*s) / 2 )

# ERRATA DISCOVERED THROUGH PAINFUL PROCESS: Factor of 1/2 in eq. 31 in
# paper is placed in the wrong location. It has to be moved from second term
# in the nominator to the third (logarithmic) term.

phipi=(3/(4*s**3))*(s**2-s+log(1+2*s)/2)

print("Considering the function phi^pi(s) given as:")
print()
print(unicode_art(phipi))
# Choosing Taylor expansions to be used for s<0.1 = 1/10, we find the
# order and coefficients of the Taylor expansion via (aiming for better than
# 1e-100 precision):

s_cutoff = sage_int(1)/sage_int(100)
order = sage_int(60)
print()
print("Performing taylor expansion of phi^pi(s)...")
phipi_taylor60 = phipi.taylor(s,0,order)
print("...done")
print()
print(f"Precision at order {order} at s={s_cutoff}:")
print('   absolute: %.4g' % ( (phipi_taylor60-phipi)(s=s_cutoff).n(digits=500) ) )
print('   relative: %.4g' % ( ((phipi_taylor60-phipi)/phipi)(s=s_cutoff).n(digits=500) ) )
print()
print("The coefficients in a form suitable for mpmath code:")
for c in phipi_taylor60.coefficients(s):
    print( '    c%i = mpf("%s")'%(c[1],str(c[0])) )

print('    def taylor( s ):')
print('        return c0+s*'+''.join('(c%i+s*'%i for i in range(1,order))+'c%i'%order+')'*(order-1))
